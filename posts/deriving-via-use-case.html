<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sam Tay | A small use case for Deriving Via</title>
  <meta name="description" content="Reducing boilerplate in exception hierarchies via Deriving Via.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="A small use case for Deriving Via">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://samtay.github.io/posts/deriving-via-use-case">
  <meta property="og:description" content="Reducing boilerplate in exception hierarchies via Deriving Via.">
  <meta property="og:site_name" content="Sam Tay">

  <meta name="google-site-verification" content="3Dks-zyFcUXhgficK-VIzu2wp9gCz8fNjM7sAQDYhMg" />

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://samtay.github.io/posts/deriving-via-use-case">
  <meta name="twitter:title" content="A small use case for Deriving Via">
  <meta name="twitter:description" content="Reducing boilerplate in exception hierarchies via Deriving Via.">

  
    <meta property="og:image" content="https://samtay.github.io/assets/og-image-3e064e056de498416888818acb79cc563228f840bfd7208599f86578773563da.jpg">
    <meta name="twitter:image" content="https://samtay.github.io/assets/og-image-3e064e056de498416888818acb79cc563228f840bfd7208599f86578773563da.jpg">
  

  <link href="https://samtay.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="Sam Tay Last 10 blog posts" />

  
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon-light/apple-touch-icon-2d18f0eb077831f89079d4eaddf7310f9bd08fa824ca5c783e7338fbeb8a6895.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-light/favicon-32x32-c058adc4fb4eddc2f534aafb6fd568728d834a6c006a6190abc2ac8c6ff72931.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-light/favicon-16x16-a5643dace800e8ed2f3c81d1e869f7783da139177b63cb7e087bae5b3036f694.png">
  <link rel="manifest" href="/assets/favicon-light/site-7a9e07ce1f7386689917602ddc5a75750ad842e605ff764f67173529c181bf04.webmanifest">

  

    
      <link rel="stylesheet" type="text/css" title="light" id="light" href="/assets/light-e27e2bf91650f9f57d0bb77d6edca6ccc99802019df0d26b3f94f97163aef491.css">
      <link rel="stylesheet" type="text/css" title="dark" id="dark" href="/assets/dark-a6931aaf0c0507eeb56ee2265f701c37cfcecde13463e8a7dfa9b8966cda3e8e.css" disabled="true">
    

  

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="Sam Tay">Sam Tay</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-about">
  <use href="/assets/about-ecf154b571ab8034ae00aeed91a3b7ad68db80b46d958753ad6216c919486e88.svg#icon-about" xlink:href="/assets/about-ecf154b571ab8034ae00aeed91a3b7ad68db80b46d958753ad6216c919486e88.svg#icon-about"></use>
</svg>

        </a>
      </li>
    
    
    
    
    
      <li>
        <a href="https://github.com/samtay" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/assets/github-094f81040819f34343ee6ffff0980f17e2807b08b595eaaf66ae3554934fd78d.svg#icon-github" xlink:href="/assets/github-094f81040819f34343ee6ffff0980f17e2807b08b595eaaf66ae3554934fd78d.svg#icon-github"></use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:sam.chong.tay@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/assets/email-782473193bf750036fdb90e8daa075508a20509d01854c09f3237c144a3f0601.svg#icon-email" xlink:href="/assets/email-782473193bf750036fdb90e8daa075508a20509d01854c09f3237c144a3f0601.svg#icon-email"></use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/assets/rss-541ec5cea9cefd10d2fcfec01888f3f231a8829940249835fa7b7b3a12ae0d0d.svg#icon-rss" xlink:href="/assets/rss-541ec5cea9cefd10d2fcfec01888f3f231a8829940249835fa7b7b3a12ae0d0d.svg#icon-rss"></use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a onclick="toggle()" title="Toggle Theme">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-theme">
  <use href="/assets/theme-66869e0bf8dab34bae1c86bda400327b772e0be69e8dc28d3ede896e771320ed.svg#icon-theme" xlink:href="/assets/theme-66869e0bf8dab34bae1c86bda400327b772e0be69e8dc28d3ede896e771320ed.svg#icon-theme"></use>
</svg>

        </a>
      </li>
    
  </ul>
</nav>



        <article class="article scrollappear">
          <header class="article-header">
            <h1>A small use case for Deriving Via</h1>
            <p>Reducing boilerplate in exception hierarchies via Deriving Via.</p>
            <div class="article-list-footer">
  <span class="article-list-date">
    March 11, 2019
  </span>
  <span class="article-list-divider">-</span>
  <span class="article-list-minutes">
    
    
      5 minute read
    
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      
      <a href="/tag/haskell" title="See all posts with tag 'Haskell'">Haskell</a>
    
  </div>
</div>

          </header>

          <div class="article-content">
            <h2 id="introduction">Introduction</h2>

<p>I am going to show a small but practical scenario for which
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via">DerivingVia</a>,
a language extension introduced in GHC 8.6, is a natural solution.
The extension is aptly named, as it extends the customizability of deriving
clauses, namely to allow you to specify that a type should derive a typeclass
instance <em>via</em> another type’s instance.</p>

<p>As is typical for me as a lowly software engineer that writes Haskell, as opposed to a
computer scientist researching programming language theory, the description of the
language extension initially seemed opaque. In hindsight, I would argue it is one of the
simple-yet-still-incredibly-useful extensions.</p>

<h2 id="motivation">Motivation</h2>

<p>The motivating example that I recently came across at work is implementing an exception
hierarchy. In fact, I wasn’t even writing a full blown exception hierarchy. All I wanted
to do was have an exception handler that catches all exceptions that have a certain
typeclass <code class="language-plaintext highlighter-rouge">HasHttpStatus</code> which looks like</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">HttpStatus</span> <span class="o">=</span> <span class="kt">HttpStatus</span>
  <span class="p">{</span> <span class="n">httpStatusCode</span>    <span class="o">::</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">httpStatusMessage</span> <span class="o">::</span> <span class="kt">String</span>
  <span class="p">}</span>

<span class="kr">class</span> <span class="kt">HasHttpStatus</span> <span class="n">e</span> <span class="kr">where</span>
  <span class="n">toHttpStatus</span> <span class="o">::</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="kt">HttpStatus</span></code></pre></figure>

<p>Now if I have some exceptions with natural http statuses, such as</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">NotFoundError</span> <span class="o">=</span> <span class="kt">NotFoundError</span>
  <span class="kr">deriving</span> <span class="kt">Exception</span>

<span class="kr">instance</span> <span class="kt">HasHttpStatus</span> <span class="kt">NotFoundError</span>
  <span class="kr">where</span> <span class="n">toHttpStatus</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Status</span> <span class="mi">404</span> <span class="s">"Not Found"</span>

<span class="kr">data</span> <span class="kt">UnauthorizedError</span> <span class="o">=</span> <span class="kt">UnauthorizedError</span>
  <span class="kr">deriving</span> <span class="kt">Exception</span>

<span class="kr">instance</span> <span class="kt">HasHttpStatus</span> <span class="kt">UnauthorizedError</span>
  <span class="kr">where</span> <span class="n">toHttpStatus</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Status</span> <span class="mi">401</span> <span class="s">"Unauthorized"</span></code></pre></figure>

<p>Then in my route handler, surrounding my application business logic, I want to catch such
errors so I can return the appropriate http status:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">insertEntityRoute</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">insertEntityRoute</span> <span class="o">=</span> <span class="n">catchAppErrors</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="o">...</span>

<span class="n">catchAppErrors</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">catchAppErrors</span> <span class="o">=</span> <span class="n">flip</span> <span class="n">catches</span>
  <span class="p">[</span> <span class="kt">Handler</span> <span class="o">$</span> <span class="nf">\</span><span class="n">e</span> <span class="o">::</span> <span class="kt">SomeHttpException</span> <span class="o">-&gt;</span>
      <span class="n">sendHttpStatus</span> <span class="p">(</span><span class="n">toHttpStatus</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">,</span> <span class="kt">Handler</span> <span class="o">$</span> <span class="nf">\</span><span class="n">e</span> <span class="o">::</span> <span class="kt">SomeException</span>     <span class="o">-&gt;</span> <span class="kr">do</span>
      <span class="n">logError</span> <span class="p">(</span><span class="s">"something awful has happened: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">e</span><span class="p">)</span>
      <span class="n">sendHttpStatus</span> <span class="p">(</span><span class="kt">Status</span> <span class="mi">500</span> <span class="s">"Internal Server Error"</span><span class="p">)</span>
  <span class="p">]</span></code></pre></figure>

<p>My first attempt simply mimicked the definition of the <code class="language-plaintext highlighter-rouge">Exception</code> and <code class="language-plaintext highlighter-rouge">SomeException</code>
types.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">SomeHttpException</span>
  <span class="o">=</span>  <span class="n">forall</span> <span class="n">e</span><span class="o">.</span> <span class="p">(</span><span class="kt">Exception</span> <span class="n">e</span><span class="p">,</span> <span class="kt">HasHttpStatus</span> <span class="n">e</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">SomeHttpException</span> <span class="n">e</span>
  <span class="kr">deriving</span> <span class="kt">Typeable</span>

<span class="kr">instance</span> <span class="kt">Exception</span> <span class="kt">SomeHttpException</span> <span class="kr">where</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">SomeHttpException</span> <span class="kr">where</span>
  <span class="n">showsPrec</span> <span class="n">p</span> <span class="p">(</span><span class="kt">SomeHttpException</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">showsPrec</span> <span class="n">p</span> <span class="n">e</span>

<span class="kr">instance</span> <span class="kt">HasHttpStatus</span> <span class="kt">SomeHttpException</span> <span class="kr">where</span>
  <span class="n">toHttpStatus</span> <span class="p">(</span><span class="kt">SomeHttpException</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">toHttpStatus</span> <span class="n">e</span></code></pre></figure>

<p>This is on the right track, but I initially (and ignorantly) thought this would be enough
to use my handler above. Of course, nothing was being caught by the <code class="language-plaintext highlighter-rouge">SomeHttpException</code>
handler. Instead, it became clear after looking in the
<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#t:Exception">Control.Exception</a>
documentation that I would need to write custom <code class="language-plaintext highlighter-rouge">Exception</code>
instances for all of my http errors. So my final pull request looked just like what the
documentation advises (and is what is most likely familiar to anyone who has implemented
an exception hierarchy in Haskell):</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">httpExceptionToException</span>
  <span class="o">::</span> <span class="p">(</span><span class="kt">Exception</span> <span class="n">e</span><span class="p">,</span> <span class="kt">HasHttpStatus</span> <span class="n">e</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="o">-&gt;</span> <span class="kt">SomeException</span>
<span class="n">httpExceptionToException</span> <span class="o">=</span> <span class="n">toException</span> <span class="o">.</span> <span class="kt">SomeHttpException</span>

<span class="n">httpExceptionFromException</span>
  <span class="o">::</span> <span class="kt">Exception</span> <span class="n">e</span>
  <span class="o">=&gt;</span> <span class="kt">SomeException</span>
  <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">e</span>
<span class="n">httpExceptionFromException</span> <span class="n">e</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kt">SomeHttpException</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">fromException</span> <span class="n">e</span>
  <span class="n">cast</span> <span class="n">x</span>

<span class="kr">instance</span> <span class="kt">Exception</span> <span class="kt">NotFoundError</span> <span class="kr">where</span>
  <span class="n">toException</span> <span class="o">=</span> <span class="n">httpExceptionToException</span>
  <span class="n">fromException</span> <span class="o">=</span> <span class="n">httpExceptionFromException</span>

<span class="kr">instance</span> <span class="kt">Exception</span> <span class="kt">UnauthorizedError</span> <span class="kr">where</span>
  <span class="n">toException</span> <span class="o">=</span> <span class="n">httpExceptionToException</span>
  <span class="n">fromException</span> <span class="o">=</span> <span class="n">httpExceptionFromException</span></code></pre></figure>

<p>With these <code class="language-plaintext highlighter-rouge">Exception</code> instances, my handler defined above works as expected. I didn’t
like having to duplicate these instances (in my case there were quite a few more instances
to write), but I trusted that this was the accepted solution since it was in the
documentation and I came up dry googling for better solutions.</p>

<h2 id="derivingvia">DerivingVia</h2>
<p>However, a colleage at work (<a href="https://github.com/asivitz"><strong>@asivitz</strong></a> on GitHub, for credit) spotted the
duplicate instances and refactored this by enabling <code class="language-plaintext highlighter-rouge">DerivingVia</code>. With this approach, we
need only write an <code class="language-plaintext highlighter-rouge">Exception</code> instance for one newtype wrapper, and then we can auto-derive
the rest of our http error instances via the newtype wrapper:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">newtype</span> <span class="kt">HttpException</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">HttpException</span> <span class="n">e</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">e</span> <span class="o">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">showsPrec</span> <span class="n">p</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">showsPrec</span> <span class="n">p</span> <span class="n">e</span>

<span class="kr">instance</span> <span class="kt">HasHttpStatus</span> <span class="n">e</span> <span class="o">=&gt;</span> <span class="kt">HasHttpStatus</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">toHttpStatus</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">toHttpStatus</span> <span class="n">e</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">e</span><span class="p">,</span> <span class="kt">HasHttpStatus</span> <span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Exception</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="n">e</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">toException</span> <span class="o">=</span> <span class="n">httpExceptionToException</span>
    <span class="n">fromException</span> <span class="o">=</span> <span class="n">httpExceptionFromException</span></code></pre></figure>

<p>Now we can use this <code class="language-plaintext highlighter-rouge">HttpException</code> wrapper instance in our deriving clauses.
The error types will instead be defined as:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">NotFoundError</span> <span class="o">=</span> <span class="kt">NotFoundError</span>
  <span class="kr">deriving</span> <span class="kt">Exception</span> <span class="n">via</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="kt">NotFoundError</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">UnauthorizedError</span> <span class="o">=</span> <span class="kt">UnauthorizedError</span>
  <span class="kr">deriving</span> <span class="kt">Exception</span> <span class="n">via</span> <span class="p">(</span><span class="kt">HttpException</span> <span class="kt">UnauthorizedError</span><span class="p">)</span></code></pre></figure>

<p>The syntax is wonderfully clear here. It is evident when reading the deriving
clause above that the exception instance for <code class="language-plaintext highlighter-rouge">e</code> is precisely the one that we
have defined for <code class="language-plaintext highlighter-rouge">HttpException e</code>.  So our <code class="language-plaintext highlighter-rouge">SomeHttpException</code> handler will
still catch both of these exceptions, but we get to remove our explicit
typeclass implementations.</p>

<h2 id="conclusion">Conclusion</h2>
<p>The lesson here is that if you find yourself writing identical typeclass instances over and
over, possibly accumulating a mountain of boilerplate in your codebase: stop, drop, and
derive via.</p>

          </div>

          
          <script id="utterances_script"
                  src="https://utteranc.es/client.js"
                  repo="samtay/samtay.github.io"
                  issue-term="pathname"
                  label="comments"
                  theme="github-light"
                  crossorigin="anonymous"
                  async>
          </script>
          <script>
            // wait for utterances to load and send its first message.
            addEventListener('message', event => {
              var tone = localStorage.getItem('theme');
              if (!tone || event.origin !== 'https://utteranc.es') {
                return;
              }
              const message = {
                type: 'set-theme',
                theme: 'github-' + tone
              };
              const utterances = document.querySelector('iframe').contentWindow;
              utterances.postMessage(message, 'https://utteranc.es');
            });
          </script>
          

          
        </article>
        <footer class="footer scrollappear">
  <p>
  Ramblings ϵ {Mathematics, Statistics, Haskell}.
    &copy; 2020. All rights reserved.
    <!--<a href="/about" title="About me">Nielsen Ramon</a>. Download it <a href="https://github.com/nielsenramon/chalk" rel="noreferrer noopener" target="_blank" title="Download Chalk">here</a>.-->
  </p>
</footer>

      </div>
    </div>
  </main>
  

<script src="/assets/vendor-130c9c254effc51f3283620bc635851da7b99c20901216948f11ba72ee13317f.js" type="text/javascript"></script>


  <script src="/assets/webfonts-96493456d319d1bf419afdf8701552d4d486fee6afd304897d4fd81eb4e0cc0b.js" type="text/javascript"></script>



  <script src="/assets/scrollappear-e2da8ea567e418637e31266cc5302126eaa79f62a2273739086358b589a89ee6.js" type="text/javascript"></script>


<script src="/assets/application-cfde13ac81ddaf4351b2e739603e2baf688d0fcc9aba613fe62bbb1c7b037fb9.js" type="text/javascript"></script>


  <script src="/assets/themetoggle-592c116ce4dcad7dc732f6ffd55b682581fae9e8737bca3da323e802faf1367f.js" type="text/javascript"></script>

</body>
</html>
