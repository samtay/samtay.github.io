<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
  <title>Sam Tay | A small use case for Deriving Via</title>

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link href="../css/poole.css" rel="stylesheet" type="text/css" />
  <link href="../css/syntax.css" rel="stylesheet" type="text/css" />
  <link href="../css/hyde.css" rel="stylesheet" type="text/css" />
  <link href="../css/font-awesome-animation.min.css" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="Sam Tay's FP dabbles" href="./feed.xml">
  <link rel="alternate" type="application/atom+xml" title="Sam Tay's FP dabbles" href="./atom.xml">

  <!-- External assets -->
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
</head>


  <body class="theme-base-08">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="../">Sam Tay</a>
      </h1>
      <p class="lead">The ramblings of an opinionated functional programmer.</p>
    </div>

    <nav class="sidebar-nav">
      <!-- TODO map over pages and each page has 'active' field %-->
      <a class="sidebar-nav-item" href="../">Home</a>
      <a class="sidebar-nav-item" href="../about.html">About</a>
      <div class="sidebar-nav-external">
        <a href="https://github.com/samtay" title="Github">
          <i class="fa fa-github faa-shake animated-hover"></i>
        </a>
        <a href="mailto:sam.chong.tay@gmail.com" title="Email">
          <i class="fa fa-envelope faa-shake animated-hover"></i>
        </a>
        <a href="../feed.xml" title="RSS">
          <i class="fa fa-rss faa-shake animated-hover" aria-hidden="true"></i>
        </a>
      </div>
    </nav>

    <p>&copy; 2018. All rights reserved.</p>
  </div>
</div>


    <div class="content container"><div class="post">
  <h1 class="post-title">A small use case for Deriving Via</h1>
  <span class="post-date">March 11, 2019</span>
  <div id="toc"><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#derivingvia">DerivingVia</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></div>
<h2 id="introduction">Introduction</h2>
<p>I am going to show a small but pratical scenario for which <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via">DerivingVia</a>, a language extension introduced in GHC 8.6, is a natural solution. The extension is aptly named, as it extends the customizability of deriving clauses, namely to allow you to specify that a type should derive a typeclass instance <em>via</em> another type’s instance.</p>
<p>As is typical for me as a lowly software engineer that writes Haskell, as opposed to a computer scientist researching programming language theory, the description of the language extension initially seemed opaque. In hindsight, I would argue it is one of the simple-yet-still-incredibly-useful extensions.</p>
<h2 id="motivation">Motivation</h2>
<p>The motivating example that I recently came across at work is implementing an exception hierarchy. In fact, I wasn’t even writing a full blown exception hierarchy. All I wanted to do was have an exception handler that catches all exceptions that have a certain typeclass <code>HasHttpStatus</code> which looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HttpStatus</span> <span class="fu">=</span> <span class="dt">HttpStatus</span>
  {<span class="ot"> httpStatusCode    ::</span> <span class="dt">Int</span>
  ,<span class="ot"> httpStatusMessage ::</span> <span class="dt">String</span>
  }

<span class="kw">class</span> <span class="dt">HasHttpStatus</span> e <span class="kw">where</span>
<span class="ot">  toHttpStatus ::</span> e <span class="ot">-&gt;</span> <span class="dt">HttpStatus</span></code></pre></div>
<p>Now if I have some exceptions with natural http statuses, such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NotFoundError</span> <span class="fu">=</span> <span class="dt">NotFoundError</span>
  <span class="kw">deriving</span> <span class="dt">Exception</span>

<span class="kw">instance</span> <span class="dt">HasHttpStatus</span> <span class="dt">NotFoundError</span>
  <span class="kw">where</span> toHttpStatus _ <span class="fu">=</span> <span class="dt">Status</span> <span class="dv">404</span> <span class="st">&quot;Not Found&quot;</span>

<span class="kw">data</span> <span class="dt">UnauthorizedError</span> <span class="fu">=</span> <span class="dt">UnauthorizedError</span>
  <span class="kw">deriving</span> <span class="dt">Exception</span>

<span class="kw">instance</span> <span class="dt">HasHttpStatus</span> <span class="dt">UnauthorizedError</span>
  <span class="kw">where</span> toHttpStatus _ <span class="fu">=</span> <span class="dt">Status</span> <span class="dv">401</span> <span class="st">&quot;Unauthorized&quot;</span></code></pre></div>
<p>Then in my route handler, surrounding my application business logic, I want to catch such errors so I can return the appropriate http status:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertEntityRoute ::</span> <span class="dt">IO</span> ()
insertEntityRoute <span class="fu">=</span> catchAppErrors <span class="fu">$</span> <span class="kw">do</span>
  <span class="fu">...</span>

<span class="ot">catchAppErrors ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
catchAppErrors <span class="fu">=</span> flip catches
  [ <span class="dt">Handler</span> <span class="fu">$</span> \<span class="ot">e ::</span> <span class="dt">SomeHttpException</span> <span class="ot">-&gt;</span>
      sendHttpStatus (toHttpStatus e)
  , <span class="dt">Handler</span> <span class="fu">$</span> \<span class="ot">e ::</span> <span class="dt">SomeException</span>     <span class="ot">-&gt;</span> <span class="kw">do</span>
      logError (<span class="st">&quot;something awful has happened: &quot;</span> <span class="fu">++</span> show e)
      sendHttpStatus (<span class="dt">Status</span> <span class="dv">500</span> <span class="st">&quot;Internal Server Error&quot;</span>)
  ]</code></pre></div>
<p>My first attempt simply mimicked the definition of the <code>Exception</code> and <code>SomeException</code> types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeHttpException</span>
  <span class="fu">=</span>  forall e<span class="fu">.</span> (<span class="dt">Exception</span> e, <span class="dt">HasHttpStatus</span> e)
  <span class="ot">=&gt;</span> <span class="dt">SomeHttpException</span> e
  <span class="kw">deriving</span> <span class="dt">Typeable</span>

<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">SomeHttpException</span> <span class="kw">where</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">SomeHttpException</span> <span class="kw">where</span>
  showsPrec p (<span class="dt">SomeHttpException</span> e) <span class="fu">=</span> showsPrec p e

<span class="kw">instance</span> <span class="dt">HasHttpStatus</span> <span class="dt">SomeHttpException</span> <span class="kw">where</span>
  toHttpStatus (<span class="dt">SomeHttpException</span> e) <span class="fu">=</span> toHttpStatus e</code></pre></div>
<p>This is on the right track, but I initially (and ignorantly) thought this would be enough to use my handler above. Of course, nothing was being caught by the <code>SomeHttpException</code> handler. Instead, it became clear after looking in the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#t:Exception">Control.Exception</a> documentation that I would need to write custom <code>Exception</code> instances for all of my http errors. So my final pull request looked just like what the documentation advises (and is what is most likely familiar to anyone who has implemented an exception hierarchy in Haskell):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">httpExceptionToException
<span class="ot">  ::</span> (<span class="dt">Exception</span> e, <span class="dt">HasHttpStatus</span> e)
  <span class="ot">=&gt;</span> e
  <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
httpExceptionToException <span class="fu">=</span> toException <span class="fu">.</span> <span class="dt">SomeHttpException</span>

httpExceptionFromException
<span class="ot">  ::</span> <span class="dt">Exception</span> e
  <span class="ot">=&gt;</span> <span class="dt">SomeException</span>
  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> e
httpExceptionFromException e <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">SomeHttpException</span> x <span class="ot">&lt;-</span> fromException e
  cast x

<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">NotFoundError</span> <span class="kw">where</span>
  toException <span class="fu">=</span> httpExceptionToException
  fromException <span class="fu">=</span> httpExceptionFromException

<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">UnauthorizedError</span> <span class="kw">where</span>
  toException <span class="fu">=</span> httpExceptionToException
  fromException <span class="fu">=</span> httpExceptionFromException</code></pre></div>
<p>With these <code>Exception</code> instances, my handler defined above works as expected. I didn’t like having to duplicate these instances (in my case there were quite a few more instances to write), but I trusted that this was the accepted solution since it was in the documentation and I came up dry googling for better solutions.</p>
<h2 id="derivingvia">DerivingVia</h2>
<p>However, a colleage at work (<a href="https://github.com/asivitz"><strong><span class="citation">@asivitz</span></strong></a> on GitHub, for credit) spotted the duplicate instances and refactored this by enabling <code>DerivingVia</code>. With this approach, we need only write an <code>Exception</code> instance for one newtype wrapper, and then we can auto-derive the rest of our http error instances via the newtype wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">HttpException</span> e <span class="fu">=</span> <span class="dt">HttpException</span> e

<span class="kw">instance</span> <span class="dt">Show</span> e <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">HttpException</span> e) <span class="kw">where</span>
  showsPrec p (<span class="dt">HttpException</span> e) <span class="fu">=</span> showsPrec p e

<span class="kw">instance</span> <span class="dt">HasHttpStatus</span> e <span class="ot">=&gt;</span> <span class="dt">HasHttpStatus</span> (<span class="dt">HttpException</span> e) <span class="kw">where</span>
  toHttpStatus (<span class="dt">HttpException</span> e) <span class="fu">=</span> toHttpStatus e

<span class="kw">instance</span> (<span class="dt">Show</span> e, <span class="dt">HasHttpStatus</span> e) <span class="ot">=&gt;</span> <span class="dt">Exception</span> (<span class="dt">HttpException</span> e)
  <span class="kw">where</span>
    toException <span class="fu">=</span> httpExceptionToException
    fromException <span class="fu">=</span> httpExceptionFromException</code></pre></div>
<p>Now we can use this <code>HttpException</code> wrapper instance in our deriving clauses. The error types will instead be defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NotFoundError</span> <span class="fu">=</span> <span class="dt">NotFoundError</span>
  <span class="kw">deriving</span> <span class="dt">Exception</span> via (<span class="dt">HttpException</span> <span class="dt">NotFoundError</span>)

<span class="kw">data</span> <span class="dt">UnauthorizedError</span> <span class="fu">=</span> <span class="dt">UnauthorizedError</span>
  <span class="kw">deriving</span> <span class="dt">Exception</span> via (<span class="dt">HttpException</span> <span class="dt">UnauthorizedError</span>)</code></pre></div>
<p>The syntax is wonderfully clear here. Sometimes extensions can be opaque, but it is evident when reading the deriving clause above that the exception instance for <code>e</code> is precisely the one that we have defined for <code>HttpException e</code>. So our <code>SomeHttpException</code> handler will still catch both of these exceptions, but we get to remove our explicit typeclass implementations.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The lesson here is that if you find yourself writing identical typeclass intances over and over, possibly accumulating a mountain of boilerplate in your codebase: stop, drop, and derive via.</p>
  <div id="disqus_thread"></div>
<script>

//  https://disqus.com/admin/universalcode/#configuration-variables
var disqus_config = function () {
  this.page.url = 'https://samtay.github.io/articles/deriving-via.html';
  this.page.identifier = 'articles/deriving-via.md';
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//samtay.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

</div>
</div>

  </body>
</html>
